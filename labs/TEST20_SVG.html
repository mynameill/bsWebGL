<!DOCTYPE html>
<html lang="ko">
<head>
	<title>svg파서 개발을 위한 초기 테스트</title>
	<meta name="keywords" content="redcamel, webgl, bsjs, bsWebGL" />
	<meta name="description" content="redcamel, webgl, bsjs, bsWebGL" />
	<meta charset="utf-8" />
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="format-detection" content="telephone=no" />
	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black" />
	<meta name="viewport"
	      content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=0.5,target-densitydpi=medium-dpi" />
	<link rel="shortcut icon" href="http://redcamel.github.io/red/red/favicon/favicon.ico" type="image/x-icon">
	<style>body {
		margin: 0;
		padding: 0;
		font-size: 11px
	}</style>
	<script src="http://projectbs.github.io/bsJS/bsjs.0.5.js"></script>

</head>
<body>
<svg style="position:absolute;z-index:1" height="500" width="500">
	<rect width="300" height="100" fill="#223344" />
	<path d="M150 0 L75 200 L225 200 L525 300" fill="#11cc44" />
	<rect width="150" height="150" fill="#22f654"></rect>
	<circle cx="50" cy="50" r="80" stroke="black" stroke-width="3" fill="#aa2244" />
	<ellipse cx="240" cy="100" rx="220" ry="30" fill="#aa2244" />
	<ellipse cx="220" cy="70" rx="190" ry="20" fill="#bb2244" />
	<ellipse cx="210" cy="45" rx="170" ry="15" fill="#cc2244" />
	<image xlink:href="../showcase/assets/t1.jpg" x="0" y="0" height="50px" width="50px" />
	<polygon points="200,10 250,190 160,210" fill="#cce244" />
	<polyline points="20,20 40,25 60,40 80,120 120,140 200,180" stroke="#ffee44" style="fill:none" />
	<line x1="0" y1="0" x2="200" y2="200" stroke="#cc2244" stroke-width="3" />


</svg>
<script>
	bs.debug(0)
	bs(function () {
		bs.require(function () {
			bs.GL.init('#glCanvas', '../shaders.js', init)
			function init() {

				//파서테스트
				//svg파서 개발을 위한 초기 테스트
				bs.GL['parserSVG'] = (function () {
					function checkColor(fill) {
						var t = fill ? fill : '#fff'
						// TODO rgb일떄 그냥 명시적 색상일떄도 고려해야함
						// TODO 스타일 해석도해야되는구나..
						return t
					}

					return function (svg) {
						var etc = '', r1 = /^[a-z]|[A-Z]/
						var i, j = 0, k, k2, t0 = svg.childNodes, len = t0.length, svgChild = [], type, t1, t2, t3
						for (i = 0; i < len; i++) (t0[i].nodeType != 3 && t0[i].nodeType != 8) ? svgChild.push(t0[i]) : 0
						var container = bs.GL.Mesh('rect').S('material', '#eee')
						i = svgChild.length
						while (i--) {
							var vs = [], is = [], mesh
							t1 = svgChild[j++]
							type = t1.tagName
							if (type == 'rect' || type == 'image') {
								etc = '', mesh = bs.GL.Mesh('rect').S(
										'pivotX', t1.width.baseVal.value / 2, 'pivotY', -t1.height.baseVal.value / 2,
										'scaleX', t1.width.baseVal.value, 'scaleY', t1.height.baseVal.value
								)
							} else if (type == 'ellipse' || type == 'circle') {
								etc = '', mesh = bs.GL.Mesh('circle').S(
										'x', t1.getAttribute('cx'), 'y', -t1.getAttribute('cy'),
										'scaleX', t1.getAttribute(type == 'ellipse' ? 'rx' : 'r') * 2, 'scaleY', t1.getAttribute(type == 'ellipse' ? 'ry' : 'r') * 2
								)
							} else if (type == 'polygon' || type == 'polyline') {
								etc = 'points', t2 = t1.getAttribute('points').split(' ')
								for (k = 0, len = t2.length; k < len; k++) t3 = t2[k].split(','), vs.push(t3[0]), vs.push(-t3[1]), vs.push(0)
							} else if (type == 'line') {
								var _x1 = t1.getAttribute('x1'), _x2 = t1.getAttribute('x2'), _y1 = t1.getAttribute('y1'), _y2 = t1.getAttribute('y2');
								etc = _x1 + _y1 + _x2 + _y2, vs.push(_x1), vs.push(-_y1), vs.push(0), vs.push(_x2), vs.push(-_y2), vs.push(0)
							} else if (type == 'path') {
								//TODO 공포의 베지어 패스는 나중에 -_-;;;
								var idxs = [], s1, key, v, isM;
								etc = 'd', t2 = t1.getAttribute('d').split(' ')
								for (k = 0, len = t2.length; k < len; k++) s1 = t2[k], key = r1.test(s1) ? idxs.push([k]) : idxs[idxs.length - 1].push(k)
								for (k = 0, len = idxs.length; k < len; k++) {
									for (k2 = 0; k2 < idxs[k].length; k2++) {
										v = t2[idxs[k][k2]], isM = t2[idxs[k][0]].charAt(0) == 'M'
										if (v.charAt(0) == 'M') vs.push(+v.substr(1, v.length - 1))
										else if (v.charAt(0) == 'L' && !isM) vs.push(+v.substr(1, v.length - 1))
										else if (v.charAt(0) != 'Z') vs.push(-v), vs.push(0)
									}
								}
								for (k = 0, len = Math.ceil(idxs.length / 3); k < len; k++) is.push(k), is.push(k + 1), is.push(k + 2)
//								console.log(vs, is), console.log('버퍼생성', 'path' + t1.getAttribute('d'))
							}
							if (type != 'rect' && type != 'image' && type != 'circle' && type != 'ellipse') {
								var name = type + (etc == '' ? '' : t1.getAttribute(etc));
								bs.GL.makeBufferSet(name, vs, is, []), mesh = bs.GL.Mesh(name).S('zSort', 0, '<', container),
												type == 'path' ? mesh.S('renderMode', 'TRIANGLE_FAN', 'material', checkColor(t1.getAttribute('fill'))) :
												type == 'polyline' ? mesh.S('renderMode', 'LINE_STRIP', 'material', checkColor(t1.getAttribute('stroke'))) :
												type == 'polygon' ? mesh.S('material', checkColor(t1.getAttribute('fill'))) :
												type == 'line' ? mesh.S('renderMode', 'LINES', 'material', checkColor(t1.getAttribute('stroke'))) : 0
							} else mesh.S('material', type == 'image' ? t1.getAttribute('xlink:href') + ',B' : checkColor(t1.getAttribute('fill')), 'zSort', 0, '<', container)
						}
						return container
					}
				})();
				//////////////////////////////////////////////////////////
				//////////////////////////////////////////////////////////
				var svgRect = bs.Dom('svg')[0]
				bs.GL.parserSVG(svgRect).S('<', bs.GL)
				//////////////////////////////////////////////////////////
				//////////////////////////////////////////////////////////

				var time = 0, ms = Math.sin, mc = Math.cos
				bs.ANI.ani({
					ANI: function () {
						time += 0.003
						var list = bs.GL.S('children'), i = list.length, t0, t1, j
						while (i--) {
							t0 = list[i]
							j = t0.children.length
//							t0.rotationZ += 0.001 * 15
//							while (j--) t1 = t0.children[j],t1.rotationZ += 0.001 * 15
						}
					}
				})
			}
		}, '../gl.js')

	})
</script>
</body>
</html>
