<!DOCTYPE html>
<html lang="ko">
<head>
	<title>svg파서 개발을 위한 초기 테스트</title>
	<meta name="keywords" content="redcamel, webgl, bsjs, bsWebGL" />
	<meta name="description" content="redcamel, webgl, bsjs, bsWebGL" />
	<meta charset="utf-8" />
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="format-detection" content="telephone=no" />
	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black" />
	<meta name="viewport"
	      content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=0.5,target-densitydpi=medium-dpi" />
	<link rel="shortcut icon" href="http://redcamel.github.io/red/red/favicon/favicon.ico" type="image/x-icon">
	<style>body {
		margin: 0;
		padding: 0;
		font-size: 11px
	}</style>
	<script src="http://projectbs.github.io/bsJS/bsjs.0.5.js"></script>

</head>
<body>
<svg style="position:absolute;z-index:1" height="500" width="100%">
	<rect width="300" height="100" fill="#223344" />
	<path d="M350 0 L75 200 L225 200 L525 300" fill="pink" />
	<rect width="150" height="150" fill="#22f654"></rect>
	<rect x="200" y="200" width="150" height="150" fill="purple" opacity="0.5"></rect>
	<circle cx="50" cy="50" r="80" stroke="black" stroke-width="3" fill="blue" />
	<circle cx="150" cy="150" r="30" stroke="black" stroke-width="3" fill="rgb(0,100,125)" />
	<ellipse cx="240" cy="100" rx="220" ry="30" fill="#aa2244" />
	<ellipse cx="220" cy="70" rx="190" ry="20" fill="#bb2244" />
	<ellipse cx="210" cy="45" rx="170" ry="15" fill="rgb(0,100,125)" />
	<image xlink:href="../showcase/assets/t1.jpg" x="0" y="0" height="50px" width="50px" />
	<image xlink:href="../showcase/assets/t1.jpg" x="100" y="100" height="50px" width="50px" />
	<polygon points="200,10 250,190 160,210" fill="#cce244" opacity="0.5" />
	<polyline points="20,20 40,25 60,40 80,120 120,140 200,180" stroke="#ffee44" style="fill:none" />
	<line x1="0" y1="0" x2="200" y2="200" stroke="#cc2244" stroke-width="3" />
	<path d="M0 0 C200 200, 400 200, 500 100" stroke="#006666" fill="none" />
</svg>
<script>
	bs.debug(0)
	bs(function () {
		bs.require(function () {
			bs.GL.init('#glCanvas', '../shaders.js', init)
			function init() {
				bs.GL.controller.S('distance', 1000)
				//파서테스트
				//svg파서 개발을 위한 초기 테스트
				bs.GL['parserSVG'] = (function () {
					var f0, f1, f2, colorNamed = {aliceblue: '#F0F8FF', antiquewhite: '#FAEBD7', aqua: '#00FFFF', aquamarine: '#7FFFD4', azure: '#F0FFFF', beige: '#F5F5DC', bisque: '#FFE4C4', black: '#000000', blanchedalmond: '#FFEBCD', blue: '#0000FF', blueviolet: '#8A2BE2', brown: '#A52A2A', burlywood: '#DEB887', cadetblue: '#5F9EA0', chartreuse: '#7FFF00', chocolate: '#D2691E', coral: '#FF7F50', cornflowerblue: '#6495ED', cornsilk: '#FFF8DC', crimson: '#DC143C', cyan: '#00FFFF', darkblue: '#00008B', darkcyan: '#008B8B', darkgoldenrod: '#B8860B', darkgray: '#A9A9A9', darkgrey: '#A9A9A9', darkgreen: '#006400', darkkhaki: '#BDB76B', darkmagenta: '#8B008B', darkolivegreen: '#556B2F', darkorange: '#FF8C00', darkorchid: '#9932CC', darkred: '#8B0000', darksalmon: '#E9967A', darkseagreen: '#8FBC8F', darkslateblue: '#483D8B', darkslategray: '#2F4F4F', darkslategrey: '#2F4F4F', darkturquoise: '#00CED1', darkviolet: '#9400D3', deeppink: '#FF1493', deepskyblue: '#00BFFF', dimgray: '#696969', dimgrey: '#696969', dodgerblue: '#1E90FF', firebrick: '#B22222', floralwhite: '#FFFAF0', forestgreen: '#228B22', fuchsia: '#FF00FF', gainsboro: '#DCDCDC', ghostwhite: '#F8F8FF', gold: '#FFD700', goldenrod: '#DAA520', gray: '#808080', grey: '#808080', green: '#008000', greenyellow: '#ADFF2F', honeydew: '#F0FFF0', hotpink: '#FF69B4', indianred: '#CD5C5C', indigo: '#4B0082', ivory: '#FFFFF0', khaki: '#F0E68C', lavender: '#E6E6FA', lavenderblush: '#FFF0F5', lawngreen: '#7CFC00', lemonchiffon: '#FFFACD', lightblue: '#ADD8E6', lightcoral: '#F08080', lightcyan: '#E0FFFF', lightgoldenrodyellow: '#FAFAD2', lightgray: '#D3D3D3', lightgrey: '#D3D3D3', lightgreen: '#90EE90', lightpink: '#FFB6C1', lightsalmon: '#FFA07A', lightseagreen: '#20B2AA', lightskyblue: '#87CEFA', lightslategray: '#778899', lightslategrey: '#778899', lightsteelblue: '#B0C4DE', lightyellow: '#FFFFE0', lime: '#00FF00', limegreen: '#32CD32', linen: '#FAF0E6', magenta: '#FF00FF', maroon: '#800000', mediumaquamarine: '#66CDAA', mediumblue: '#0000CD', mediumorchid: '#BA55D3', mediumpurple: '#9370D8', mediumseagreen: '#3CB371', mediumslateblue: '#7B68EE', mediumspringgreen: '#00FA9A', mediumturquoise: '#48D1CC', mediumvioletred: '#C71585', midnightblue: '#191970', mintcream: '#F5FFFA', mistyrose: '#FFE4E1', moccasin: '#FFE4B5', navajowhite: '#FFDEAD', navy: '#000080', oldlace: '#FDF5E6', olive: '#808000', olivedrab: '#6B8E23', orange: '#FFA500', orangered: '#FF4500', orchid: '#DA70D6', palegoldenrod: '#EEE8AA', palegreen: '#98FB98', paleturquoise: '#AFEEEE', palevioletred: '#D87093', papayawhip: '#FFEFD5', peachpuff: '#FFDAB9', peru: '#CD853F', pink: '#FFC0CB', plum: '#DDA0DD', powderblue: '#B0E0E6', purple: '#800080', rebeccapurple: '#663399', red: '#FF0000', rosybrown: '#BC8F8F', royalblue: '#4169E1', saddlebrown: '#8B4513', salmon: '#FA8072', sandybrown: '#F4A460', seagreen: '#2E8B57', seashell: '#FFF5EE', sienna: '#A0522D', silver: '#C0C0C0', skyblue: '#87CEEB', slateblue: '#6A5ACD', slategray: '#708090', slategrey: '#708090', snow: '#FFFAFA', springgreen: '#00FF7F', steelblue: '#4682B4', tan: '#D2B48C', teal: '#008080', thistle: '#D8BFD8', tomato: '#FF6347', turquoise: '#40E0D0', violet: '#EE82EE', wheat: '#F5DEB3', white: '#FFFFFF', whitesmoke: '#F5F5F5', yellow: '#FFFF00', yellowgreen: '#9ACD32"'};

					function rgbToHex() {
						var r, g, b;
						f2 = (f2 = arguments[0]).substr(4, f2.length - 5).split(','), r = +f2[0], g = +f2[1], b = +f2[2]
						return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
					}

					function checkColor() {
						if (f0 = arguments[0]) f0 = (f1 = f0.charAt(0)) == '#' ? f0 : f0.indexOf('rgb') > -1 ? rgbToHex(f0) : colorNamed[f0]
						else f0 = '#fff'
						// TODO 스타일 해석도해야되는구나..
						return f0
					}

					return function (svg) {
						var etc = '', r1 = /^[a-z]|[A-Z]/
						var i, j = 0, k, k2, t0 = svg.childNodes, len = t0.length, len2, svgChild = [], type, t1, t2, t3, t4, t4p, t5
						for (i = 0; i < len; i++) (t0[i].nodeType != 3 && t0[i].nodeType != 8) ? svgChild.push(t0[i]) : 0
						var container = bs.GL.Mesh('rect').S('material', '#eee')
						var hasC = 0
						i = svgChild.length
						while (i--) {
							var vs = [], is = [], mesh
							t1 = svgChild[j++]
							type = t1.tagName
							if (type == 'rect' || type == 'image') {
								etc = '', mesh = bs.GL.Mesh('rect').S(
										'pivotX', t1.width.baseVal.value / 2, 'pivotY', -t1.height.baseVal.value / 2,
										'x', t1.getAttribute('x'), 'y', -t1.getAttribute('y'),
										'scaleX', t1.width.baseVal.value, 'scaleY', t1.height.baseVal.value
								)
							} else if (type == 'ellipse' || type == 'circle') {
								etc = '', mesh = bs.GL.Mesh('circle').S(
										'x', t1.getAttribute('cx'), 'y', -t1.getAttribute('cy'),
										'scaleX', t1.getAttribute(type == 'ellipse' ? 'rx' : 'r') * 2, 'scaleY', t1.getAttribute(type == 'ellipse' ? 'ry' : 'r') * 2
								)
							} else if (type == 'polygon' || type == 'polyline') {
								etc = 'points', t2 = t1.getAttribute('points').split(' ')
								for (k = 0, len = t2.length; k < len; k++) t3 = t2[k].split(','), vs.push(t3[0]), vs.push(-t3[1]), vs.push(0)
							} else if (type == 'line') {
								var _x1 = t1.getAttribute('x1'), _x2 = t1.getAttribute('x2'), _y1 = t1.getAttribute('y1'), _y2 = t1.getAttribute('y2');
								etc = _x1 + _y1 + _x2 + _y2, vs.push(_x1), vs.push(-_y1), vs.push(0), vs.push(_x2), vs.push(-_y2), vs.push(0)
							} else if (type == 'path') {
								//TODO 공포의 베지어 패스는 나중에 -_-;;;
								var chunks = makeChunk(t1.getAttribute('d')), action, divideNum = 15
								etc = 'd', t2 = t1.getAttribute('d').split(' ')
								hasC = 0
								for (k = 0, len = chunks.length; k < len; k++) {
									t4 = chunks[k], t4p = t4.point
									action = t4.key.toUpperCase()
									if (action == 'C') {
										hasC = 1
										var result = [], cp = [
											{x: chunks[k - 1].point[chunks[k - 1].point.length - 2], y: chunks[k - 1].point[chunks[k - 1].point.length - 1]},
											{x: t4p[0], y: t4p[1]},
											{x: t4p[2], y: t4p[3]},
											{x: t4p[4], y: t4p[5]}
										]
										for (k2 = 0; k2 < divideNum; k2++) result[k2] = cubicBezier(cp, k2 * 1.0 / ( divideNum - 1 ));
										for (k2 = 0, len2 = result.length; k2 < len2; k2++) t5 = result[k2], vs.push(t5[0]), vs.push(-t5[1]), vs.push(t5[2])
									}
									else {
										for (k2 = 0, len2 = t4p.length; k2 < len2; k2++) {
											if (action == 'M' || action == 'L') vs.push((k2 % 2 == 1 ? -1 : 1) * t4p[k2]), k2 == t4p.length - 1 ? vs.push(0) : 0
										}
									}
								}
							}
							if (type != 'rect' && type != 'image' && type != 'circle' && type != 'ellipse') {
								var name = type + (etc == '' ? '' : t1.getAttribute(etc)), tAlpha;
								bs.GL.makeBufferSet(name, vs, is, []),
										mesh = bs.GL.Mesh(name).S('zSort', 0, '<', container, 'alpha', (tAlpha = t1.getAttribute('opacity')) ? tAlpha : 1),
												type == 'path' ? (hasC ? mesh.S('renderMode', 'LINE_STRIP', 'material', checkColor(t1.getAttribute('stroke'))) : mesh.S('renderMode', 'TRIANGLE_FAN', 'material', checkColor(t1.getAttribute('fill')))) :
												type == 'polyline' ? mesh.S('renderMode', 'LINE_STRIP', 'material', checkColor(t1.getAttribute('stroke'))) :
												type == 'polygon' ? mesh.S('material', checkColor(t1.getAttribute('fill'))) :
												type == 'line' ? mesh.S('renderMode', 'LINES', 'material', checkColor(t1.getAttribute('stroke'))) : 0
							} else mesh.S('material', type == 'image' ? t1.getAttribute('xlink:href') + ',B' : checkColor(t1.getAttribute('fill')), 'zSort', 0, '<', container, 'alpha', (tAlpha = t1.getAttribute('opacity')) ? tAlpha : 1)
						}

						function cubicBezier(p, t) {
							var ax, bx, cx, ay, by, cy;
							var tS, tC;
							var result = [];
							/* 다항식 계수를 계산한다 */
							cx = 3.0 * (p[1].x - p[0].x), bx = 3.0 * (p[2].x - p[1].x) - cx, ax = p[3].x - p[0].x - cx - bx,
									cy = 3.0 * (p[1].y - p[0].y), by = 3.0 * (p[2].y - p[1].y) - cy, ay = p[3].y - p[0].y - cy - by,
								/* 매개변수 값 t에서 곡선 점을 계산한다 */
									tS = t * t, tC = tS * t,
									result.push((ax * tC) + (bx * tS) + (cx * t) + p[0].x),
									result.push((ay * tC) + (by * tS) + (cy * t) + p[0].y),
									result.push(0)
							return result;
						}

						function makeChunk() {
							var t1 = arguments[0], t2, t3, r = /[a-z][^a-z]*/ig, trim = /^\s*|\s*$/g, i, j, len, len2;
							var source = t1.match(r), chunk, chunks = [];
							for (i = 0, len = source.length; i < len; i++) {
								t2 = source[i].replace(trim, '').split(' '), t3 = {point: []}
								for (j = 0, len2 = t2.length; j < len2; j++) chunk = t2[j].replace(',', ''), j == 0 ? (t3.key = chunk.charAt(0), t3.point.push(+chunk.substring(1, chunk.length))) : t3.point.push(+chunk)
								chunks.push(t3)
							}
							return chunks
						}

						return container
					}
				})();
				//////////////////////////////////////////////////////////
				//////////////////////////////////////////////////////////
				var svgRect = bs.Dom('svg')[0]
				bs.GL.parserSVG(svgRect).S('<', bs.GL)
				//////////////////////////////////////////////////////////
				//////////////////////////////////////////////////////////

				var time = 0, ms = Math.sin, mc = Math.cos
				bs.ANI.ani({
					ANI: function () {
						time += 0.003
						var list = bs.GL.S('children'), i = list.length, t0, t1, j
						while (i--) {
							t0 = list[i]
							j = t0.children.length
//							t0.rotationZ += 0.001 * 15
//							while (j--) t1 = t0.children[j],t1.rotationZ += 0.001 * 15
						}
					}
				})
			}
		}, '../gl.js')

	})
</script>
</body>
</html>
