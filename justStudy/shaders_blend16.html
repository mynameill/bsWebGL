<!--
컴파일된 쉐이더소스를  VS, FS라함
VS : 한정점정보에 해당하여 여러개의 어트리 뷰트를 당연히 가짐
FS : 레스터화된 픽셀포인트에 작용하며 정점값을 보간할수있다. 프래그먼트의 위치나 다른 프래그먼트의 정보를 알수는 없다.
-->
<!--쉐이더 코드 입력합니다-->
<script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;
        varying vec4 vColor;
        varying vec4 vLightColor;
        uniform float uBlend;
        float ADD ;float SUBTRACT ;float MULTIPLY ;float DARKEN ;float COLOUR_BURN ;float LINEAR_BURN ;float LIGHTEN ;float SCREEN ;float COLOUR_DODGE ;float LINEAR_DODGE ;float OVERLAY ;float SOFT_LIGHT ;float HARD_LIGHT ;float VIVID_LIGHT ;float LINEAR_LIGHT ;float PIN_LIGHT ;float DIFFERENCE ;float EXCLUSION ;float NORMAL ;
        vec3 blend (vec3 src, vec3 dst)
        {
            if(uBlend == NORMAL) return src;
            else if(uBlend == ADD)	return src + dst;
            else if(uBlend == SUBTRACT)	return src - dst;
            else if(uBlend == MULTIPLY)	return src * dst;
            else if(uBlend == DARKEN)	return min(src, dst);
            else if(uBlend == COLOUR_BURN)	return vec3((src.x == 0.0) ? 0.0 : (1.0 - ((1.0 - dst.x) / src.x)),(src.y == 0.0) ? 0.0 : (1.0 - ((1.0 - dst.y) / src.y)),(src.z == 0.0) ? 0.0 : (1.0 - ((1.0 - dst.z) / src.z)));
            else if(uBlend == LINEAR_BURN)	return (src + dst) - 1.0;
            else if(uBlend == LIGHTEN)	return max(src, dst);
            else if(uBlend == SCREEN)	return (src + dst) - (src * dst);
            else if(uBlend == COLOUR_DODGE)	return vec3((src.x == 1.0) ? 1.0 : min(1.0, dst.x / (1.0 - src.x)),(src.y == 1.0) ? 1.0 : min(1.0, dst.y / (1.0 - src.y)),(src.z == 1.0) ? 1.0 : min(1.0, dst.z / (1.0 - src.z)));
            else if(uBlend == LINEAR_DODGE)	return src + dst;
            else if(uBlend == OVERLAY)	return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),(dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),(dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));
            else if(uBlend == SOFT_LIGHT)	return vec3((src.x <= 0.5) ? (dst.x - (1.0 - 2.0 * src.x) * dst.x * (1.0 - dst.x)) : (((src.x > 0.5) && (dst.x <= 0.25)) ? (dst.x + (2.0 * src.x - 1.0) * (4.0 * dst.x * (4.0 * dst.x + 1.0) * (dst.x - 1.0) + 7.0 * dst.x)) : (dst.x + (2.0 * src.x - 1.0) * (sqrt(dst.x) - dst.x))),(src.y <= 0.5) ? (dst.y - (1.0 - 2.0 * src.y) * dst.y * (1.0 - dst.y)) : (((src.y > 0.5) && (dst.y <= 0.25)) ? (dst.y + (2.0 * src.y - 1.0) * (4.0 * dst.y * (4.0 * dst.y + 1.0) * (dst.y - 1.0) + 7.0 * dst.y)) : (dst.y + (2.0 * src.y - 1.0) * (sqrt(dst.y) - dst.y))),(src.z <= 0.5) ? (dst.z - (1.0 - 2.0 * src.z) * dst.z * (1.0 - dst.z)) : (((src.z > 0.5) && (dst.z <= 0.25)) ? (dst.z + (2.0 * src.z - 1.0) * (4.0 * dst.z * (4.0 * dst.z + 1.0) * (dst.z - 1.0) + 7.0 * dst.z)) : (dst.z + (2.0 * src.z - 1.0) * (sqrt(dst.z) - dst.z))));
            else if(uBlend == HARD_LIGHT)	return vec3((src.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - src.x) * (1.0 - dst.x)),(src.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - src.y) * (1.0 - dst.y)),(src.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - src.z) * (1.0 - dst.z)));
            else if(uBlend == VIVID_LIGHT)	return vec3((src.x <= 0.5) ? (1.0 - (1.0 - dst.x) / (2.0 * src.x)) : (dst.x / (2.0 * (1.0 - src.x))),(src.y <= 0.5) ? (1.0 - (1.0 - dst.y) / (2.0 * src.y)) : (dst.y / (2.0 * (1.0 - src.y))),(src.z <= 0.5) ? (1.0 - (1.0 - dst.z) / (2.0 * src.z)) : (dst.z / (2.0 * (1.0 - src.z))));
            else if(uBlend == LINEAR_LIGHT)	return 2.0 * src + dst - 1.0;
            else if(uBlend == PIN_LIGHT)	return vec3((src.x > 0.5) ? max(dst.x, 2.0 * (src.x - 0.5)) : min(dst.x, 2.0 * src.x),(src.x > 0.5) ? max(dst.y, 2.0 * (src.y - 0.5)) : min(dst.y, 2.0 * src.y),(src.z > 0.5) ? max(dst.z, 2.0 * (src.z - 0.5)) : min(dst.z, 2.0 * src.z));// ADD
            else if(uBlend == DIFFERENCE)	return abs(dst - src);
            else if(uBlend == EXCLUSION)	return src + dst - 2.0 * src * dst;
            else return src;
        }
        void main(void) {
             NORMAL =0.0;ADD=1.0;SUBTRACT=2.0;MULTIPLY=3.0;DARKEN=4.0;COLOUR_BURN=5.0;LINEAR_BURN =6.0;LIGHTEN =7.0;SCREEN =8.0;COLOUR_DODGE =9.0;LINEAR_DODGE =10.0;OVERLAY =11.0;SOFT_LIGHT=12.0;HARD_LIGHT =13.0;VIVID_LIGHT =14.0;LINEAR_LIGHT =15.0;PIN_LIGHT =16.0;DIFFERENCE =17.0;EXCLUSION =18.0;
             gl_FragColor = vec4(vColor[0], vColor[1], vColor[2], vColor[3]);
             gl_FragColor = gl_FragColor*vLightColor;
        }
</script>
<!--쉐이더 코드 입력합니다-->
<script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        uniform vec4 aColor;
        varying vec4 vColor;
        uniform vec4 aLightColor;
        varying vec4 vLightColor;
        uniform vec3 uPosition;
        uniform vec3 uRotation;
        uniform vec3 uCposition;
        uniform vec3 uCrotation;
        uniform mat4 uPMatrix;
        mat4 cal(vec3 p,vec3 t)
        {
            float s = sin(t[0]);float c = cos(t[0]);mat4 m1 = mat4( 1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1);
            s = sin(t[1]);c = cos(t[1]);mat4 m2 = mat4(c,0,s,0, 0,1,0,0, -s,0,c,0, 0,0,0,1);
            s = sin(t[2]);c = cos(t[2]);mat4 m3 = mat4(c,-s,0,0, s,c,0,0, 0,0,1,0, 0,0,0,1);
            return  mat4(1,0,0,0, 0,1,0,0, 0,0,1,0, p[0],p[1],p[2],1)*m1*m2*m3;
        }
        void main(void) {
            vColor =aColor;
            vLightColor =aLightColor;
            gl_Position =uPMatrix*cal(uCposition,uCrotation)*cal(uPosition,uRotation)*vec4(aVertexPosition, 1.0);
        }
</script>
<!--쉐이더 코드 입력합니다-->
<script id="shader-fs-bitmap" type="x-shader/x-fragment">
        precision mediump float;
        uniform sampler2D uSampler; // 샘플러 상수로 선언하고
        varying vec2 vTextureCoord; // 텍스트 코디네이터 정보..즉 유브이가됨...
        varying vec4 vColor;
        varying vec4 vLightColor;
        varying float lambertTerm;
        uniform float uBlend;
        float ADD ;float SUBTRACT ;float MULTIPLY ;float DARKEN ;float COLOUR_BURN ;float LINEAR_BURN ;float LIGHTEN ;float SCREEN ;float COLOUR_DODGE ;float LINEAR_DODGE ;float OVERLAY ;float SOFT_LIGHT ;float HARD_LIGHT ;float VIVID_LIGHT ;float LINEAR_LIGHT ;float PIN_LIGHT ;float DIFFERENCE ;float EXCLUSION ;float NORMAL ;
        vec3 blend (vec3 src, vec3 dst)
        {
            if(uBlend == NORMAL) return src;
            else if(uBlend == ADD)	return src + dst;
            else if(uBlend == SUBTRACT)	return src - dst;
            else if(uBlend == MULTIPLY)	return src * dst;
            else if(uBlend == DARKEN)	return min(src, dst);
            else if(uBlend == COLOUR_BURN)	return vec3((src.x == 0.0) ? 0.0 : (1.0 - ((1.0 - dst.x) / src.x)),(src.y == 0.0) ? 0.0 : (1.0 - ((1.0 - dst.y) / src.y)),(src.z == 0.0) ? 0.0 : (1.0 - ((1.0 - dst.z) / src.z)));
            else if(uBlend == LINEAR_BURN)	return (src + dst) - 1.0;
            else if(uBlend == LIGHTEN)	return max(src, dst);
            else if(uBlend == SCREEN)	return (src + dst) - (src * dst);
            else if(uBlend == COLOUR_DODGE)	return vec3((src.x == 1.0) ? 1.0 : min(1.0, dst.x / (1.0 - src.x)),(src.y == 1.0) ? 1.0 : min(1.0, dst.y / (1.0 - src.y)),(src.z == 1.0) ? 1.0 : min(1.0, dst.z / (1.0 - src.z)));
            else if(uBlend == LINEAR_DODGE)	return src + dst;
            else if(uBlend == OVERLAY)	return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),(dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),(dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));
            else if(uBlend == SOFT_LIGHT)	return vec3((src.x <= 0.5) ? (dst.x - (1.0 - 2.0 * src.x) * dst.x * (1.0 - dst.x)) : (((src.x > 0.5) && (dst.x <= 0.25)) ? (dst.x + (2.0 * src.x - 1.0) * (4.0 * dst.x * (4.0 * dst.x + 1.0) * (dst.x - 1.0) + 7.0 * dst.x)) : (dst.x + (2.0 * src.x - 1.0) * (sqrt(dst.x) - dst.x))),(src.y <= 0.5) ? (dst.y - (1.0 - 2.0 * src.y) * dst.y * (1.0 - dst.y)) : (((src.y > 0.5) && (dst.y <= 0.25)) ? (dst.y + (2.0 * src.y - 1.0) * (4.0 * dst.y * (4.0 * dst.y + 1.0) * (dst.y - 1.0) + 7.0 * dst.y)) : (dst.y + (2.0 * src.y - 1.0) * (sqrt(dst.y) - dst.y))),(src.z <= 0.5) ? (dst.z - (1.0 - 2.0 * src.z) * dst.z * (1.0 - dst.z)) : (((src.z > 0.5) && (dst.z <= 0.25)) ? (dst.z + (2.0 * src.z - 1.0) * (4.0 * dst.z * (4.0 * dst.z + 1.0) * (dst.z - 1.0) + 7.0 * dst.z)) : (dst.z + (2.0 * src.z - 1.0) * (sqrt(dst.z) - dst.z))));
            else if(uBlend == HARD_LIGHT)	return vec3((src.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - src.x) * (1.0 - dst.x)),(src.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - src.y) * (1.0 - dst.y)),(src.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - src.z) * (1.0 - dst.z)));
            else if(uBlend == VIVID_LIGHT)	return vec3((src.x <= 0.5) ? (1.0 - (1.0 - dst.x) / (2.0 * src.x)) : (dst.x / (2.0 * (1.0 - src.x))),(src.y <= 0.5) ? (1.0 - (1.0 - dst.y) / (2.0 * src.y)) : (dst.y / (2.0 * (1.0 - src.y))),(src.z <= 0.5) ? (1.0 - (1.0 - dst.z) / (2.0 * src.z)) : (dst.z / (2.0 * (1.0 - src.z))));
            else if(uBlend == LINEAR_LIGHT)	return 2.0 * src + dst - 1.0;
            else if(uBlend == PIN_LIGHT)	return vec3((src.x > 0.5) ? max(dst.x, 2.0 * (src.x - 0.5)) : min(dst.x, 2.0 * src.x),(src.x > 0.5) ? max(dst.y, 2.0 * (src.y - 0.5)) : min(dst.y, 2.0 * src.y),(src.z > 0.5) ? max(dst.z, 2.0 * (src.z - 0.5)) : min(dst.z, 2.0 * src.z));// ADD
            else if(uBlend == DIFFERENCE)	return abs(dst - src);
            else if(uBlend == EXCLUSION)	return src + dst - 2.0 * src * dst;
            else return src;
        }
        void main(void) {
             NORMAL =0.0;ADD=1.0;SUBTRACT=2.0;MULTIPLY=3.0;DARKEN=4.0;COLOUR_BURN=5.0;LINEAR_BURN =6.0;LIGHTEN =7.0;SCREEN =8.0;COLOUR_DODGE =9.0;LINEAR_DODGE =10.0;OVERLAY =11.0;SOFT_LIGHT=12.0;HARD_LIGHT =13.0;VIVID_LIGHT =14.0;LINEAR_LIGHT =15.0;PIN_LIGHT =16.0;DIFFERENCE =17.0;EXCLUSION =18.0;
             vec4 dst = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
	         vec4 src = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
	         vec3 colour = clamp(blend(src.xyz, dst.xyz), 0.0, 1.0);
	         gl_FragColor.xyz = colour;
	         gl_FragColor = gl_FragColor*vLightColor*lambertTerm;
	         gl_FragColor.w = src.w*vColor[3];
        }
</script>
<!--쉐이더 코드 입력합니다-->
<script id="shader-vs-bitmap" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        attribute vec3 aVertexNormal;

        varying vec2 vTextureCoord;
        varying float lambertTerm;

        uniform vec4 aColor;
        varying vec4 vColor;

        uniform vec4 aLightColor;
        varying vec4 vLightColor;
        uniform vec3 uLightDirection;

        uniform vec3 uPosition;
        uniform vec3 uRotation;
        uniform vec3 uCposition;
        uniform vec3 uCrotation;
        uniform mat4 uPMatrix;
        mat4 cal(vec3 p,vec3 t)
        {
            float s = sin(t[0]);float c = cos(t[0]);mat4 m1 = mat4( 1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1);
            s = sin(t[1]);c = cos(t[1]);mat4 m2 = mat4(c,0,s,0, 0,1,0,0, -s,0,c,0, 0,0,0,1);
            s = sin(t[2]);c = cos(t[2]);mat4 m3 = mat4(c,-s,0,0, s,c,0,0, 0,0,1,0, 0,0,0,1);
            return  mat4(1,0,0,0, 0,1,0,0, 0,0,1,0, p[0],p[1],p[2],1)*m1*m2*m3;
        }
        void main(void) {
          vColor =aColor;
          vLightColor =aLightColor;
          vTextureCoord = aTextureCoord;
          vec3 N = aVertexPosition;
          vec3 LD = normalize(uLightDirection);
          lambertTerm = dot(N,-LD);
          gl_Position =uPMatrix*cal(uCposition,uCrotation)*cal(uPosition,uRotation)*vec4(aVertexPosition, 1.0);
        }
</script>

<!--걍필터 테스트-->
<!--쉐이더 코드 입력합니다-->
<script id="shader-fs-filter" type="x-shader/x-fragment">
        precision mediump float;
        uniform sampler2D uSampler; // 샘플러 상수로 선언하고
        varying vec2 vTextureCoord; // 텍스트 코디네이터 정보..즉 유브이가됨...
        varying vec4 vColor;

        uniform float uFilter;
        float NORMAL; float GRAY; float SEPIA; float INVERT; float PIXEL;float BLUR; float SHAPEN;float SHAPENESS;float EDGE;float EDGE2;float EMBOSS;
        const mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);

        uniform float uTime;
        uniform float uUseWave;

        // 픽셀
        uniform vec4 dimensions;
        uniform vec2 pixelSize;

        // 컨볼루션
        uniform vec2 u_textureSize;
        uniform float u_kernel[9];

        void main(void) {
            NORMAL = 0.0,GRAY = 1.0,SEPIA = 2.0,INVERT = 3.0,PIXEL = 4.0,BLUR = 5.0,SHAPEN = 6.0,SHAPENESS = 7.0,EDGE = 8.0,EDGE2 = 9.0,EMBOSS = 10.0;
            vec2 redVcode;
            if(uUseWave == 1.0){
                redVcode.s = vTextureCoord.s + (sin(uTime+vTextureCoord.t*35.0)*0.015)+sin(uTime)/25.0;
                redVcode.t = vTextureCoord.t + (cos(uTime+vTextureCoord.s*35.0)*0.015)+cos(uTime)/25.0;
            }else  redVcode = vTextureCoord;
            vec4 prev = texture2D(uSampler, redVcode); // 샘플러에서 받아오고 저장함..
            //prev = vec4(prev.rgba * vColor); // 컬러랑 더해줌
            gl_FragColor = prev; // 프레그먼크 컬러내보냄
            if(uFilter == GRAY) gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), 1.0);
            else if(uFilter == INVERT)	gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - 1.0);
            else if(uFilter == SEPIA) gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, 1.0);
            else if(uFilter == PIXEL) {
                vec2 coord = redVcode;
                vec2 size = dimensions.xy/pixelSize;
                vec2 color = floor( ( redVcode * size ) ) / size + pixelSize/dimensions.xy * 0.5;
                gl_FragColor = texture2D(uSampler, color);
            }
             else if(uFilter > PIXEL ) {
                vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
                vec4 colorSum =
                 texture2D(uSampler, redVcode + onePixel * vec2(-1, -1)) * u_kernel[0] +
                 texture2D(uSampler, redVcode + onePixel * vec2( 0, -1)) * u_kernel[1] +
                 texture2D(uSampler, redVcode + onePixel * vec2( 1, -1)) * u_kernel[2] +
                 texture2D(uSampler, redVcode + onePixel * vec2(-1,  0)) * u_kernel[3] +
                 texture2D(uSampler, redVcode + onePixel * vec2( 0,  0)) * u_kernel[4] +
                 texture2D(uSampler, redVcode + onePixel * vec2( 1,  0)) * u_kernel[5] +
                 texture2D(uSampler, redVcode + onePixel * vec2(-1,  1)) * u_kernel[6] +
                 texture2D(uSampler, redVcode + onePixel * vec2( 0,  1)) * u_kernel[7] +
                 texture2D(uSampler, redVcode + onePixel * vec2( 1,  1)) * u_kernel[8] ;
                float kernelWeight =u_kernel[0] +u_kernel[1] +u_kernel[2] +u_kernel[3] +u_kernel[4] +u_kernel[5] +u_kernel[6] +u_kernel[7] +u_kernel[8] ;
                if (kernelWeight <= 0.0) kernelWeight = 1.0;
                gl_FragColor = vec4((colorSum / kernelWeight).rgb, 1.0);
            }
            else gl_FragColor = prev;
        }
</script>

<!--쉐이더 코드 입력합니다-->
<script id="shader-vs-filter" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        varying vec2 vTextureCoord;
        uniform vec4 aColor;
        varying vec4 vColor;
        void main(void) {
          vTextureCoord =aTextureCoord;
          gl_Position =vec4(aVertexPosition, 1.0);
        }
</script>
